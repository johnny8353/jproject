程序、进程、线程的概念
Java中多线程的创建和使用
	继承 Thread 类与实现 Runnable  接口
	Thread类的主要方法
	线程的调度与设置优先级
线程的生命周期
线程的同步
线程的通信


程序、进程、线程的概念
	程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。
	进程(process)是程序的一次执行过程，或是正在运行的一个程序。动态过程：有它自身的产生、存在和消亡的过程。
		如：运行中的QQ，运行中的MP3播放器
		程序是静态的，进程是动态的
	线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。
		若一个程序可同一时间执行多个线程，就是支持多线程的
		
Java中多线程的创建和使用
	何时需要多线程
		程序需要同时执行两个或多个任务。
		程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。
		需要一些后台运行的程序时。
	继承 Thread 类与实现 Runnable  接口
		Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。
		Thread类的特性
			每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体
			通过该Thread对象的start()方法来调用这个线程
		构造方法
			Thread()：创建新的Thread对象
			Thread(String threadname)：创建线程并指定线程实例名
			Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法
			Thread(Runnable target, String name)：创建新的Thread对象 
		
		创建线程的两种方式
			继承Thread类
				 1)  定义子类继承Thread类。
				 2)  子类中重写Thread类中的run方法。
				 3)  创建Thread子类对象，即创建了线程对象。
				 4)  调用线程对象start方法：启动线程，调用run方法。
			 实现Runnable接口
				1）定义子类，实现Runnable接口。
				2）子类中重写Runnable接口中的run方法。
				3）通过Thread类含参构造器创建线程对象。
				4）将Runnable接口的子类对象作为实际参数传递给
				      Thread类的构造方法中。
				5）调用Thread类的start方法：开启线程，调用
				      Runnable子类接口的run方法。

		继承方式和实现方式的联系与区别
		【区别】
			继承Thread:      线程代码存放Thread子类run方法中。
			实现Runnable：	线程代码存在接口的子类的run方法。
		【实现方法的好处】
			1）避免了单继承的局限性
			2）多个线程可以共享同一个接口实现类的对象，非常适合多个相同线程来处理同一份资源。
	Thread类的主要方法
		Thread类的有关方法(1)
			void start():  启动线程，并执行对象的run()方法
			run():  线程在被调度时执行的操作
			String getName():  返回线程的名称
			void setName(String name):设置该线程名称
			static currentThread(): 返回当前线程
			static  void  yield()：线程让步
				暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程
				若队列中没有同优先级的线程，忽略此方法
				调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。它跟sleep方法类似，同样不会释放锁。
				但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。
　				注意，调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。
			join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止   
				低优先级的线程也可以获得执行 
			static  void  sleep(long millis)：(指定时间:毫秒)
				令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。
				*但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。
				抛出InterruptedException异常
			stop(): 强制线程生命期结束
			boolean isAlive()：返回boolean，判断线程是否还活着
			interrupt方法
　　				-interrupt，顾名思义，即中断的意思。单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；
				-另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。
				-所以说直接调用interrupt方法不能中断正在运行中的线程。
　　				-但是如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，
				那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。
	线程的调度与设置优先级
		线程的调度
		调度策略
			时间片
			抢占式：高优先级的线程抢占CPU 
			Java的调度方法
				同优先级线程组成先进先出队列（先到先服务），使用时间片策略
				对高优先级，使用优先调度的抢占式策略
		线程的优先级控制
			MAX_PRIORITY（10）;    
			MIN _PRIORITY （1）;  
			NORM_PRIORITY （5）;
			涉及的方法：
			-getPriority() ：返回线程优先值 
			-setPriority(int newPriority) ：改变线程的优先级
			-线程创建时继承父线程的优先级
			
		使用多线程的优点
			背景：只使用单个线程完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？

			多线程程序的优点：
				提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
				提高计算机系统CPU的利用率
				改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改
		线程的分类
			Java中的线程分为两类：一种是守护线程，一种是用户线程。
				它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。
				守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程。
				Java垃圾回收就是一个典型的守护线程。
				若JVM中都是守护线程，当前JVM将退出。
线程的生命周期
	JDK中用Thread.State枚举表示了线程的几种状态
		http://www.cnblogs.com/dolphin0520/p/3920357.html
	要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：
		新建NEW： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态
		就绪RUNNABLE：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件
		运行RUNNIND：当就绪的线程被调度并获得处理器资源时,便进入运行状态， run()方法定义了线程的操作和功能
		阻塞BLOCKED、WAITING、TIMED_WAITING：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态
		死亡TERMINATED：线程完成了它的全部工作或线程被提前强制性地中止   
		
线程的同步

	互斥锁
		在Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
			每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
			关键字synchronized 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问。
			同步的局限性：导致程序的执行效率要降低
			同步方法（非静态的）的锁为this。
			同步方法（静态的）的锁为当前类本身。
	释放锁的操作
		当前线程的同步方法、同步代码块执行结束
		当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。
		当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束
		当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。
	**不会释放锁的操作
		线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行
		线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。
			应尽量避免使用suspend()和resume()来控制线程
	线程的死锁问题
	死锁
		不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
	解决方法
		专门的算法、原则
		尽量减少同步资源的定义
					
线程的通信

	wait() 与 notify() 和 notifyAll()
		wait()：令当前线程挂起并放弃CPU、同步资源，使别的线程可访问并修改共享资源，而当前线程排队等候再次对资源的访问
		notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待
		notifyAll ()：唤醒正在排队等待资源的所有线程结束等待.
		
			wait() 方法
				在当前线程中调用方法：  对象名.wait()
				使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。
				调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
				调用此方法后，当前线程将释放对象监控权  ，然后进入等待
				在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。
			notify()/notifyAll()
				在当前线程中调用方法：  对象名.notify()
				功能：唤醒等待该对象监控权的一个线程。
				调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）
			
	Java.lang.Object提供的这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报java.lang.IllegalMonitorStateException异常
	
	卖票
	生产者消费者
	定时任务组件
