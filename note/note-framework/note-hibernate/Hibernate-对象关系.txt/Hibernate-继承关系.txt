对于面向对象的程序设计语言而言，继承和多态是两个最基本的概念。Hibernate 的继承映射可以理解持久化类之间的继承关系。
例如：人和学生之间的关系。学生继承了人，可以认为学生是一个特殊的人，如果对人进行查询，学生的实例也将被得到。

Hibernate支持三种继承映射策略：
	使用 subclass 进行映射：将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态。 
	使用 joined-subclass 进行映射： 对于继承关系中的子类使用同一个表，这就需要在数据库表中增加额外的区分子类类型的字段。 
	使用  union-subclass 进行映射：域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。这也就相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系。

采用 subclass 元素的继承映射
	- 采用 subclass 的继承映射可以实现对于继承关系中父类和子类使用同一张表
	- 因为父类和子类的实例全部保存在同一个表中，因此需要在该表内增加一列，使用该列来区分每行记录到低是哪个类的实例----这个列被称为辨别者列(discriminator).
	- 在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 discriminator-value 属性指定辨别者列的值
	- 所有子类定义的字段都不能有非空约束。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中
		数据：
		ID	TYPE	NAME	AGE	SCHOOL
		1	PERSON	AA	11	\N
		2	STUDENT	BB	22	johnny
	

	关键配置：
 		<!-- 映射子类 Student, 使用 subclass 进行映射 -->
        <subclass name="Student" discriminator-value="STUDENT">
        	<property name="school" type="string" column="SCHOOL"></property>
        </subclass>
        
采用 joined-subclass 元素的继承映射
	- 采用 joined-subclass 元素的继承映射可以实现每个子类一张表
	- 采用这种映射策略时，父类实例保存在父类表中，子类实例由父类表和子类表共同存储。因为子类实例也是一个特殊的父类实例，因此必然也包含了父类实例的属性。于是将子类和父类共有的属性保存在父类表中，
		子类增加的属性，则保存在子类表中。
	- 在这种映射策略下，无须使用鉴别者列，但需要为每个子类使用 key 元素映射共有主键。
	- 子类增加的属性可以添加非空约束。因为子类的属性和父类的属性没有保存在同一个表中
		ID	NAME	AGE
		1	AA	11
		2	BB	22
		
		STUDENT_id	SCHOOL
		2			johnny

	关键配置：
        <joined-subclass name="Student2" table="STUDENTS2">
        	<key column="STUDENT_id"></key>
        	<property name="school" type="string" column="SCHOOL"></property>
        </joined-subclass>
        
采用 union-subclass 元素的继承映射
	- 采用 union-subclass 元素可以实现将每一个实体对象映射到一个独立的表中。
	- 子类增加的属性可以有非空约束 --- 即父类实例的数据保存在父表中，而子类实例的数据保存在子类表中。
	- 子类实例的数据仅保存在子类表中, 而在父类表中没有任何记录
	- 在这种映射策略下，子类表的字段会比父类表的映射字段要多,因为子类表的字段等于父类表的字段、加子类增加属性的总和
	- 在这种映射策略下，既不需要使用鉴别者列，也无须使用 key 元素来映射共有主键.
	- 使用 union-subclass 映射策略是不可使用 identity 的主键生成策略, 因为同一类继承层次中所有实体类都需要使用同一个主键种子, 即多个持久化实体对应的记录的主键应该是连续的. 
	受此影响, 也不该使用 native 主键生成策略, 因为 native 会根据数据库来选择使用 identity 或 sequence.
		ID	NAME	AGE
		1	AA	11
		2	BB	22
		ID	NAME	AGE	SCHOOL
		2	BB	22	johnny

	关键配置：
		<union-subclass name="Student3" table="STUDENTS3">
			<property name="school" column="SCHOOL" type="string"></property>
		</union-subclass>  
	

对比			I. union-subclass	II.subclass			III.union-subclass
比较方面		I.每个具体类一张表		II.每个分层结构一张表		III.每个子类一张表
建立关系模型原则	I.每个具体类对应一张表，有多少具体类就需要建立多少个独立的表		II.描述一个继承关系只用一张表，也就是说子类所使用的表与父类相同			III.每个子类使用一张表，但这些子类所对应的表都关联到基类所对应的表中
关系模型的优缺点	I.这种设计方式符合关系模型的设计原则，但有表中存在重复字段的问题		II.缺点有二：首先表中引入的区分子类的字段，也就是包括了描述其他字段的字段。其次，如果某个子类的某个属性不能为空，那么在数据库一级不能设置该字段not null(非空)		III.这种设计方式完全符合关系模型的设计原则，且不存在冗余
可维护性		I.如果需要对基类进行修改，则需要对基类以及该类的子类所对应的所有表都进行修改		II.维护起来方便，只需要修改一个表		III.维护起来比较方便，对每个类的修改只需要修改其所对应的表
灵活性		I.映射的灵活性很大，子类可以包括基类属性在内的每一个属性进行单独配置		II.灵活性差，表中冗余字段会随着子类的增多而越来越多		III.灵活性很好，完全是参照对象继承的方式进行配置
查询性能		I.对于子类的查询只需要访问单独的表，对父类查询怎需要检索所有的表			II.在任何情况下，都只需处理一个表		III.对于父类的查询需要使用左外链接，对于子类查询需要使用内链接
维护性能		I.对于单个对象持久话操作只需要处理一个表			II.对于单个对象的持久话操作只需要处理一个表		III.对于子类的持久话至少要处理两个表
